# 시발쉘

## readline

< 메뉴얼 해석 >

많은 프로그램들이 CLI(command line interface)를 제공한다.

대표적으로 shell, mail, ftp등이 있다.

몇몇 프로그램들에겐 readline의 기본동작만으로 충분하다.

### 역할

- 사용자로부터 한 줄을 입력받는다.

### 헤더

![스크린샷 2022-06-04 오후 3.06.28.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.06.28.png)

readline 헤더의 정의들이 stdio 라이브러리를 사용하기때문에

readline 헤더 이전에 반드시 stdio.h 헤더가 와야한다.

### 컴파일

위 헤더들과 더불어서

```c
gcc -lreadline 파일명.c
```

로 컴파일 해야 사용할 수 있다.

### 사용법

- char *prompt에는 사용자에게 입력받을때 띄우고 싶은 문자열을 입력한다.
- prompt가 NULL이면 아무런 문자열을 표시하지 않는다.
- 사용자가 입력한 문자열을 char *로 리턴해주는데, malloc되어 있으므로, 할당해제는 필수!!!
- 개행이 삭제된 상태로 리턴해준다(enter키로 입력받기때문에 newline이 입력될 것 같지만, 리턴받는 문자열은 개행 전까지의 문자열만을 포함한다.)

![스크린샷 2022-06-04 오후 3.12.16.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.12.16.png)

## rl_on_new_line

![스크린샷 2022-06-04 오후 3.52.08.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.52.08.png)

업데이트 함수들에게 새로운 라인으로 이동했다고 알린다.

## rl_redisplay

![스크린샷 2022-06-04 오후 4.01.07.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.01.07.png)

rl_line_buffer 에 현재 들어있는 내용을 반영하기위해 스크린에 있는 내용을 바꾼다.

## rl_line_buffer

![스크린샷 2022-06-04 오후 4.10.31.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.10.31.png)

readline 관련 함수 작성자들이 사용할 수 있는 변수 중 하나이다.

## rl_replace_line

![스크린샷 2022-06-04 오후 4.05.31.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.05.31.png)

rl_line_buffer에 있는 내용을 인자로 받은 text 문자열로 대체한다.

위 3개 함수는 아마 bash 화면 조정에만 사용되고 큰 역할은 없을 것 같음.

### ref

1. stackoverflow [https://stackoverflow.com/questions/6727171/using-readline-for-completion](https://stackoverflow.com/questions/6727171/using-readline-for-completion)
2. readline 라이브러리 메뉴얼 [https://tiswww.case.edu/php/chet/readline/readline.html](https://tiswww.case.edu/php/chet/readline/readline.html)

## add_history

많은 프로그램들은 한 번에 유저로부터 입력을 받는다.

이 함수또한 GNU history 라이브러리의 함수인데, 각 줄의 임의의 데이터와 관련해 유저가 입력한 데이터들을 추적할 수 있다.

이에따라, 새로운 것을 구성할 때, 이전의 줄 들의 정보를 활용할 수 있다.

history 라이브러리를 사용하는 프로그래머들은 history list의 줄들을 기억하는 함수들, 삭제하는 함수, list에서 원하는 정보를 찾는 함수를 사용할 수 있다.

이 라이브러리가 가진 함수를 사용하기 위해선

```c
#include <readline/history.h>
```

를 include해야한다.

## history storage

### 개요

history list는 history 객체의 배열이다.

history 객체는 아래와 같다.

![스크린샷 2022-06-04 오후 4.53.48.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.53.48.png)

그리고 history list는 아래와 같이 정의되어 있다.

![스크린샷 2022-06-04 오후 4.54.26.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.54.26.png)

history library의 상태를 가진 구조체도 있는데, 이는 

![스크린샷 2022-06-04 오후 4.55.33.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.55.33.png)

요로코롬 저장되어있습니다

### 함수 정의

그래서 add_history함수는 

![스크린샷 2022-06-04 오후 4.56.29.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_4.56.29.png)

이런 형태를 가지고 있는데, string으로 들어온 이 문자를 history list의 마지막 history 객체로 추가해준다.

단, history객체의 data부분은 NULL이다.

## fork

![스크린샷 2022-06-04 오후 6.40.49.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.40.49.png)

새로운 프로세스(자식 프로세스)를 생성.

### 개요

이 자식프로세스는 함수를 호출한 프로세스의 완벽한 복사본이다.

단, 완벽한 복사본일지라도, 구분할 수 있어야하는데, 이에는 4가지가 있다.

1. 자식프로세스는 자신만의 유일한 PID를 가진다.
2. 자식프로세스의 PPID는 부모의 PPID와 다르다.
3. 자식 프로세스는 자신만의 부모의 descriptor들의 복사본을 가진다.
    - 이 디스크립터들은 같은 객체를 참조한다. 따라서 자식프로세스와 부모프로세스 간
        
        파일 객체에 대한 파일포인터는 공유된다.
        
    - 따라서 자식 프로세스에서 lseek함수를 디스크립터에 사용하는 것은 부모에게도 영향을 줄 수 있다.
    - 이 디스크립터 복사본은 쉘이 새로 생성되는 프로세스들의 표준 입출력 생성하는데에 사용되며
    - 파이프를 만드는데에도 사용된다.
    - 자식프로세스의 자원 사용은 0으로 설정된다.

### 리턴값

만약 프로세스 생성이 완료되면 포크함수는 자식프로세스에게는 0을, 부모프로세스에게는 자식의 PID를 준다.

만약 실패하면 부모프로세스에게는 -1을 리턴해주고, 자식프로세스는 생성되지 않는다.

그리고 errno가 해당 에러를 나타내기위해 설정된다.

### 주의사항

완전히 안전하려면 자식 프로세스에선 exec함수 중 하나가 사용되기 전까지 

 async-signal-safe 함수만을 사용하도록 제한해야한다.

signal-safe함수들 목록 [https://man7.org/linux/man-pages/man7/signal-safety.7.html](https://man7.org/linux/man-pages/man7/signal-safety.7.html)

## wait

![스크린샷 2022-06-04 오후 7.14.55.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.14.55.png)

### 개요

wait함수는 호출한 프로세스의 실행을 정지한다.

주로 fork를 통해 자식프로세스를 생성했을 때 사용한다.

wait을 부모프로세스에서 사용하면, 자식프로세스가 종료될때까지 부모프로세스는 휴면상태가 된다.

자식프로세스가 종료되기 전에 부모프로세스가 종료되어 orphan(고아)가 되는 것을 방지하기위한 목적이다.

자식프로세스가 종료되면 함수가 즉시 리턴되어 자식이 사용한 모든 시스템 자원을 해제한다.

근데, 어쩌다보면 부모가 wait을 호출하기전에 자식프로세스가 종료되는 경우도 있다(SEGV 등)

그 경우, 자식프로세스가 좀비프로세스가되는데, wait함수는 즉시 리턴되게 되어있다.

종료된 자식 프로세스의 ID는 0이며, 에러일 경우 -1이다.

### man

man page에선 wait함수가 자식프로세스가 종료되면서 함수 인자의 `stat_loc` 정보가 사용가능하거나 signal을 받을때까지 부모프로세스를 정지한다고 나타낸다.

wait함수가 성공적으로 리턴되면 stat_loc 은 자식프로세스의 exit상태를 나타내게된다.

## wait4

wait4함수는 자식프로세스가 종료될때까지 기다려야하는 프로그램에 좀 더 많은 인터페이스를 제공한다.

자식프로세스에 의해 사용된 자원통계나, option을 필요로한다.

다른 wait함수들은 wait4함수를 이용해 만들어졌다.

wait에서 사용되는 pid인자의 경우 어떤 자식 프로세스가 기다려야하는지 특정한다.

만약 pid가 -1이라면, 자식프로세스 중 아무거나를 지정한다.

만약 pid가 0이면 wait을 호출한 프로세스의 그룹에 속한 자식프로세스를 대상으로 기다린다.

만약 pid가 0보다 크면 해당 pid를 가진 프로세스의 종료만을 기다린다.

만약 pid가 -1보다 작으면 그 pid의 절대값과 같은 프로세스 그룹의 종료를 기다린다.

stat_loc 인자는 자식프로세스의 상태를 나타내는데에 쓰이는데, 이 인자를 아래의 매크로에 던져서 테스트를 하게된다. 

![스크린샷 2022-06-04 오후 7.46.34.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.46.34.png)

option인자는 bit연산을 통해 2개 중 하나를 가진다.

- WHOHANG 옵션은 상태를 보고하고 싶어하는 프로세스가 전혀 없다면 wait호출 시, block하지 않도록 하는데에 사용된다.
- WUNTRACED옵션은 SIGTTIN SIGTTOU SIGTSTP SIGSTOP 에 의해 종료된 자식 프로세스가 자신의 상태를 보고하고자 할때 사용된다.

rusage가 0이 아니라면, 종료된 프로세스에 의해 사용된 자원의 요약과 프로세스의 모든 자식이 반환된다.

이 정보의 경우에는 중지된 프로세스에 대해선 사용될 수 없다.

WHOHANG옵션이 지정되었는데, 아무런 자식프로세스가 상태보고를 원하지 않는다면 wait4함수는 pid 0을 반환한다.

waitpid 함수는 wait4함수의 rusage를 0으로 사용한 것과 같다.

wait3함수는 wait4함수의 pid값을 -1로 한 것과 같다.

### 주의

만약에 부모프로세스가 자식프로세스가 끝나기 전에 종료되면 남은 자식프로세스들은 1 프로세스(init)에게 입양된다.

wait으로 기다리는 중에 signal이 발생하면 signal action 루틴이 리턴되면 wait이 Interrupted되거나 재시작된다. 

## getcwd

![스크린샷 2022-06-04 오후 8.39.00.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.39.00.png)

현재 작업중인 디렉터리의 절대경로를 buf 메모리에 넣는다.

그리고 buf의 포인터를 리턴한다.

size 인자는 buf에 참조된 배열의 바이트단위 크기를 의미한다.

만약에 buf가 널포인터면 path문자열을 담을 수 있는만큼 메모리가 할당되고, size인자는 무시된다.

→ free해줘야함 나중에

## chdir

![스크린샷 2022-06-04 오후 8.43.15.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.43.15.png)

path인자는 디렉터리의 경로에 대한 포인터이다.

chdir함수는 현재 작업 디렉터리(current working directory)를 path로 바꿔준다.

경로 이름의 경로 검색 시작점이 /로 시작하지 않는다.

→ 해석 너무 씹이라서 함수 써보면서 공부해야할 듯

## stat

file의 상태를 얻는다.

![스크린샷 2022-06-04 오후 8.47.29.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.47.29.png)

stat구조체

![스크린샷 2022-06-04 오후 8.55.49.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.55.49.png)

![스크린샷 2022-06-04 오후 8.58.53.png](%E1%84%89%E1%85%B5%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B0%E1%86%AF%20f4cb3c2bcad04294a38754f798d87660/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2022-06-04_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_8.58.53.png)

stat함수는 path로 지정된 파일에 대한 정보를 획득한다.

파일에 대한 rwx 권한은 요구되지 않으나, 파일의 경로에 명시된 directory들은 반드시 검색가능해야한다.

lstat함수는 stat함수와 다른점이 파일이 심볼릭 링크일때이다.

lstat함수는 심볼릭 링크에 대한 정보를 리턴하는데, stat함수는 심볼릭 링크가 참조중인 파일에 대한 정보를 리턴한다.

심볼릭 링크에서 st_mode 멤버변수는 파일타입 매크로들과 사용될때 유용한 정보를 포함한다.

그리고 st_size멤버변수는 심볼릭 링크에 포함된 경로의 길이를 가진다.
